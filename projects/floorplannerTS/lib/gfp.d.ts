export declare class Floorplan extends go.Diagram {    private _palettes;    private _pointNodes;    private _dimensionLinks;    private _angleNodes;    constructor(div: HTMLDivElement | string);    palettes: Array<go.Palette>;    pointNodes: go.Set<go.Node>;    dimensionLinks: go.Set<go.Link>;    angleNodes: go.Set<go.Node>;    convertPixelsToUnits(num: number): number;    convertUnitsToPixels(num: number): number;    protected getUnitsAbbreviation(units: string): string;    convertUnits(oldUnits: string, newUnits: string, num: number): number;    makeDefaultFurniturePaletteNodeData(): Array<any>;    makeDefaultWallpartsPaletteNodeData(): Array<any>;    enableWallBuilding(): void;    enableDividerBuilding(): void;    disableWallBuilding(): void;    checkboxChanged(checkboxId: string): void;    changeUnits(form: HTMLFormElement): void;    changeUnitsConversionFactor(unitsConversionFactorInput: HTMLInputElement, gridSizeInput?: HTMLInputElement): void;    changeGridSize(gridSizeInput: HTMLInputElement): void;    private getCounterClockwiseWallSide;    getLinesIntersection(a1: go.Point, a2: go.Point, b1: go.Point, b2: go.Point): go.Point | null;    updateAllRoomBoundaries(changedWalls: go.Set<go.Group>): void;    maybeAddRoomNode(pt: go.Point, floorImage: string, roomToUpdate?: go.Node | null): boolean;    getRoomWalls(pt: go.Point): Array<any> | null;    makePolygonFromRoomBoundaries(path: Array<any>): go.List<go.Point> | null;    sortWallsClockwise(a: go.Group, b: go.Group): number;    sortWallsClockwiseWithSetStartWall(walls: go.List<go.Group>, wall: go.Group): go.List<go.Group>;    addInternalWallsToRoom(roomOuterBoundaryPts: go.List<go.Point>, roomOuterBoundaryPath: Array<any>): Array<any>;    getClockwiseWallEndpoint(w: go.Group, side: number): go.Point | null;    findRoomHoles(roomBoundaryWalls: Array<any>, pt: go.Point): Array<Array<any>>;    getPathPts(path: Array<any>): go.List<go.Point>;    getPolygonArea(vs: Array<go.Point>): number;    getRoomArea(r: go.Node): number;    isPointInWall(w: go.Group, p: go.Point): boolean;    isPointInRoom(r: go.Node, p: go.Point): boolean;    isPointInPolygon(vs: Array<go.Point>, point: go.Point): boolean;    updateWall(wall: go.Group): void;    updateRoom(room: go.Node): void;    private getAdjustedPoint;    buildDimensionLink(wall: go.Group, index: number, point1: go.Point, point2: go.Point, angle: number, wallOffset: number, soloWallFlag: boolean, floorplan: Floorplan, miteringSide: number, opacity?: number, stroke?: string, strokeWidth?: number): void;    updateWallDimensions(wallsToDisplayFor?: go.Set<go.Group>): void;    rotateAndTranslatePoint(pt: go.Point, angle: number, distance: number): go.Point;    getWallsIntersection(w1: go.Group, w2: go.Group): go.Point | null;    getSegmentsIntersection(p1: go.Point, p2: go.Point, p3: go.Point, p4: go.Point): go.Point | null;    updateWallAngles(): void;    findClosestLocOnWall(wall: go.Group, part: go.Part): go.Point | null;}export {};export declare class FloorplanPalette extends go.Palette {    constructor(div: HTMLDivElement | string, floorplan: Floorplan);}export declare class NodeLabelDraggingTool extends go.Tool {    private label;    private _offset;    private _originalAlignment;    private _originalCenter;    constructor();    canStart(): boolean;    findLabel(): go.GraphObject | null;    doActivate(): void;    doDeactivate(): void;    doStop(): void;    doCancel(): void;    doMouseMove(): void;    doMouseUp(): void;    updateAlignment(): void;}export declare class WallBuildingTool extends go.Tool {    private _startPoint;    private _endPoint;    private _wallReshapingTool;    private _buildingWall;    private _isBuildingDivider;    constructor();    startPoint: go.Point | null;    endPoint: go.Point | null;    wallReshapingTool: WallReshapingTool | null;    buildingWall: go.Group | null;    isBuildingDivider: boolean;    doActivate(): void;    doMouseDown(): void;    doKeyDown(): void;    doMouseMove(): void;    doDeactivate(): void;}export declare class WallReshapingTool extends go.Tool {    private _handleArchetype;    private _handle;    private _adornedShape;    private _angle;    private _length;    private _reshapeObjectName;    private _isBuilding;    private _returnData;    private _returnPoint;    private _isIntersecting;    private _wallIntersecting;    private _joinedWalls;    constructor();    readonly handleArchetype: go.Shape;    handle: go.GraphObject | null;    adornedShape: go.Shape | null;    angle: number;    length: number;    reshapeObjectName: string;    isBuilding: boolean;    returnData: any;    returnPoint: go.Point | null;    isIntersecting: boolean;    wallIntersecting: go.Group | null;    joinedWalls: go.Set<go.Group>;    updateAdornments(part: go.Part): void;    canStart(): boolean;    doActivate(): void;    doMouseMove(): void;    private getClosestIntersectingWall;    pointsApproximatelyEqual(p1: go.Point, p2: go.Point): boolean;    private performMitering;    getAllWallIntersectionPoints(): go.Set<string>;    getAllWallsAtIntersection(intersectionPoint: go.Point | null, includeDividers?: boolean): go.List<go.Group>;    private doWallsShareAnEndpoint;    maybeSplitWall(): void;    private splitNewWall;    private maybePerformWallSplit;    splitAllWalls(): void;    private areWallsParallel;    isWallColinear(wa: go.Group, wb: go.Group): boolean;    private findAllColinearWalls;    joinColinearWalls(): void;    private performColinearWallJoining;    private maintainWallParts;    private getUpdatedEntry;    joinAllColinearWalls(): void;    translateAndRotatePoint(point: go.Point, angle: number, offset: number): go.Point;    private premiterWall;    private premiterAllWalls;    performMiteringOnWall(w: go.Group): void;    performMiteringAtPoint(pt: go.Point, performPremitering?: boolean): void;    performAllMitering(): void;    private isClockwise;    private isPointOnSegment;    doMouseUp(): void;    doDeactivate(): void;    makeAdornment(selelt: go.Shape): go.Adornment;    makeHandle(): go.Shape;    calcAngleAndLengthFromHandle(mousePt: go.Point): void;    snapPointToGrid(point: go.Point): go.Point;    reshape(newPoint: go.Point): void;    showMatches(): void;    checkPtLinedUp(pt: go.Point, comparePtCoord: number, ptCoord: number, comparePt: go.Point): void;    private reshapeWall;    private getWallPartEndpoints;}